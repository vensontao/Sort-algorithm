/*************************************************************************************/
/*         冒泡排序算法函数
/*------------------------------------------------------------------------------------
/*  作    者：vensontao
/*  版 本 号：1.0.0
/*  创建时间：2017-01-09
/*------------------------------------------------------------------------------------
/*  冒泡排序时间复杂度最好的情况为O(n), 最坏的情况是O(n^2), 是稳定的排序算法
/*  基本思想是:两两比较相邻记录的关键字,如果反序则交换 
/************************************************************************************/

#include <stdio.h>

//===================================================================================
// @ 冒泡排序经典算法: ( n 为元素个数)
//     ○ 外层循环控制循环轮数（i< n-1）
//     ○ 内层循环控制循环次数（j< n-1-i）
//===================================================================================
void Bubble_Sort(int a[], int n)
{
    int i, j, temp;
    for (i = 0; i < n-1; i++)
    {
        for (j = 0; j < n-1-i; j++)
        {
            if(a[j] > a[j+1])
            {
                temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
            }
        }
    }
}

//===================================================================================
// 冒泡排序优化一：
// *   设置一个标记来标志一趟比较是否发生交换 
// *   如果没有发生交换，则说明数组已经有序, 直接退出
//===================================================================================
void Bubble_Sort_1(int a[], int n)//n为数组a的元素个数
{
    int i, j, temp;
    for(i=0; i<n-1; i++)           // 最多进行N-1轮比较
    {
        int isSorted = 0;          // 每一轮比较前n-1-i个，即已排序好的最后i个不用比较
        for(j=0; j<n-1-i; j++)
        {
            if(a[j] > a[j+1])
            {
                isSorted = 1;
                temp = a[j];
                a[j] = a[j+1];
                a[j+1]=temp;
            }
        }
        if(isSorted==0)
            break;         //如果没有发生交换，说明数组已经排序好了
    }
}

//===================================================================================
// * 冒泡排序优化二：
// * 用一个变量记录下最后一个发生交换的位置，后面没有发生交换的已经有序 
// * 所以可以用这个值来作为下一次比较结束的位置 
//===================================================================================
void Bubble_Sort_2(int* arr, int n)
{
    int i, j;
    int k = n-1, pos = 0;//pos变量用来标记循环里最后一次交换的位置  
    for (i=0; i < n-1; i++)//一共要排序size-1次
    {
        int flag = 0;                // 每次遍历标志位都要先置为0，才能判断后面的元素是否发生了交换
        for (j=0; j <k; j++)         // 选出该趟排序的最大值往后移动
        {
            if (arr[j] > arr[j + 1])
            {
                int tmp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tmp;
                flag = 1;          // 只要有发生了交换，flag就置为1
                pos = j;           // 循环里最后一次交换的位置 j赋给pos
            }
        }

        k = pos;        //判断标志位是否为0，如果为0，说明后面的元素已经有序，就直接return
        if (flag == 0)
        {
            return;
        }
    }
}

void bubbleSort2(int arr[], int n)
{
    int i = 0;
    int j = 0;
    int k = 0;
    int tmp = 0;
    int flag = n-1;

    for (i = 0; i < flag; ++i)
    {
        k = flag;
        flag = 0;
        for (j = 0; j < k; ++j)
        {
            if (arr[j] < arr[j + 1])
            {
                flag = j;
                tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
            }
        }
    }
}

//===================================================================================
// 打印输出数组元素, 其中n为数组元素个数，0~n-1；
//===================================================================================
void PrintArray(int arr[], int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        printf(" %d ", arr[i]);
    }
    printf("\n");
}

//-----------------------------------------------------------------------------------
//   主程序入口
//-----------------------------------------------------------------------------------
int main()
{
    int array[] = {95, 45, 15, 78, 84, 51, 24, 12};
    int n=sizeof(array)/sizeof(int);

    PrintArray(array, n);    // 排序前

    Bubble_Sort(array, n);

    PrintArray(array, n);    // 排序后
}